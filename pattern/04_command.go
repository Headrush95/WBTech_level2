package pattern

import "fmt"

/*
Реализовать паттерн "Команда", объяснить применимость паттерна, плюсы и минусы, а
также реальные примеры его использования на практике.
	https://en.wikipedia.org/wiki/Command_pattern

Команда - это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как
аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

Применимость:
1) когда надо параметризовать объекты выполняемым действием;
2) когда нужно ставить операции в очередь, выполнять их по расписанию или передавать по сети;
3) когда нужна операция отмены (используя паттерн "Снимок" можно хранить историю состояний или же прописывать каждой операции
функцию отмены).

Плюсы:
- убирает прямую зависимость между объектами, вызывающими операции и объектами, которые их непосредственно выполняют;
- позволяет реализовать простую отмену и повтор операций;
- позволяет реализовать отложенный запуск команд;
- позволяет собирать сложные команды из простых;
- реализует принцип открытости/закрытости (мы не трогаем исходный объект, а отдельно добавляем логику его поведения).

Минусы:
- усложняет код программы за счет дополнительных объектов.

Примеры:
1) Графический интерфейс. Допустим, у нас есть объект кнопок главного меню. В главном меню у нас есть функции сохранить
Save(), отрыть Open() и настройки Settings(). По идее, нам пришлось бы создавать еще 3 объекта кнопок: для каждой функции
свой. Данное решение приведет к огромным полотнам кода, который станет очень трудно читать. Однако, можно в объекте кнопок
создать поле с интерфейсным типом команды, которая имеет единственный метод - execute(). Таким образом, чтобы поместить
наши функции в единственный объект (класс) кнопки, нужно реализовать у них метод execute().
2) Допустим мы пишем программу для расчетов напряжено-деформированного состояния (НДС) строений, в которой можно начертить
объемную расчетную модель и рассчитать ее НДС. В таких программах необходима функция отмены, так как один неверный шаг
приведет к тому, что нужно будет перечерчивать схему или пытаться исправить текущую инструментами редактирования, а это
очень трудоемко (пламенный привет разработчикам Ansys). Чтобы избежать этого, мы можем использовать паттерн "Команда"
и хранить историю команд. Однако для этого потребуется либо каждой такой команде прописывать функцию отмены, либо хранить
состояние редактора до внесения изменений.

Реализация:
Допустим, у нас есть сервис отправки уведомлений. В зависимости от того что мы логируем изменяет сервис в который лог
отправляется. Мы можем закинуть лог в брокер и он уже сам решит куда его дальше направить, либо можем скинуть лог напрямую
в сервис мониторинга.
*/

type Command interface {
	execute(log string)
}

type Notifier struct {
	Log      string
	Receiver Command
}

// Notify - передает запись лога своему получателю - Команде
func (n *Notifier) Notify() {
	n.Receiver.execute(n.Log)
}

type Kafka struct {
}

// Отправляем лог через кафку
func (k *Kafka) execute(log string) {
	k.SendLogThroughKafka(log)
}
func (k *Kafka) SendLogThroughKafka(log string) {
	fmt.Printf("[kafka] %s\n", log)
}

type Prometheus struct {
}

// Отправляем в прометея
func (p *Prometheus) execute(log string) {
	p.SendLogToPrometheus(log)
}
func (p *Prometheus) SendLogToPrometheus(log string) {
	fmt.Printf("[Prometheus] %s\n", log)
}
