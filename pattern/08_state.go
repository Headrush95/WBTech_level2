package pattern

import "fmt"

/*
Реализовать паттерн "Состояние", объяснить применимость паттерна, плюсы и минусы, а
также реальные примеры его использования на практике.
	https://en.wikipedia.org/wiki/State_pattern

Состояние - это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от
своего состояния. Извне создаётся впечатление, что изменился класс объекта.

Применимость:
1) когда есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния. Причем состояний
много и их код часто меняется;
2) когда код объекта (класса) содержит много больших, похожих друг на друга, условных операторов, которые выбирают поведение
в зависимости от текущих значений полей объекта;
3) когда в коде используется "машина состояний", построенная на условных операторах или switch блоке, а также много дублирующихся
кусков кода.

Плюсы:
- избавляет от множества больших условных операторов машины состояний;
- концентрирует в одном месте код, связанный с определенным состоянием;
- упрощает код объекта (класса).

Минусы:
- если состояний мало и они редко меняются, то может неоправданно усложнить код

Примеры:
1) Допустим у нас есть новостной ресурс. При публикации статья проходит через состояния "черновик", "отправлен на модерацию",
"на модерации", "необходимо исправить" и "опубликовано". Все эти состояния идут последовательно, т.е. в самом состоянии
прописано какое будет следующее.
2) Заказ в интернет магазине имеет состояния. "Не оплачен", "Подтверждение", "Оплачен", "Доставка", "Доставлено". В зависимости
от этого сервис магазина по-разному будет реагировать на "Отмену заказа", на "Отслеживание" и т.п.
3) Приложение плеера в зависимости от состояния плеера будет по-разному реагировать на нажатия кнопок. Если плеер
заблокирован, то нажатие на любые кнопки вызовет экран разблокировки. Если разблокирован, то например, кнопка "Play"
включит воспроизведение музыки и поменяет состояние плеера на "проигрывание".

Реализация:
Опишем контейнер докера. Он может быть как запущенным, так и остановленным. Поле state структуры Container описывает
текущее состояние контейнера
*/

// ContainerState описывает что можно сделать с контейнером
type ContainerState interface {
	Run()
	Stop()
	GetInfo()
}

type Container struct {
	state ContainerState
}

func NewContainer() *Container {
	cont := &Container{}
	state := Stopped{cont}
	cont.state = &state
	return cont
}

func (c *Container) ChangeState(state ContainerState) {
	c.state = state
}

// контейнер делегирует выполнение команд своему состоянию

func (c *Container) Run() {
	c.state.Run()
}

func (c *Container) Stop() {
	c.state.Stop()
}

func (c *Container) GetInfo() {
	c.state.GetInfo()
}

// Опишем возможные состояния контейнера

type Running struct {
	container *Container
}

func (r *Running) Run() {
	fmt.Println("Already run")
}
func (r *Running) Stop() {
	r.container.ChangeState(&Stopped{r.container})
	fmt.Println("Stopped")
}
func (r *Running) GetInfo() {
	fmt.Println("Running")
}

type Stopped struct {
	container *Container
}

func (s *Stopped) Run() {
	s.container.ChangeState(&Running{s.container})
	fmt.Println("Running")
}

func (s *Stopped) Stop() {
	fmt.Println("Already stopped")
}

func (s *Stopped) GetInfo() {
	fmt.Println("Stopped")
}

func stateExample() {
	container := NewContainer() // по умолчанию новый контейнер не запущен
	container.Run()             // запускаем его
	container.Run()             // уже запущен...
	container.Stop()            // останавливаем
	container.GetInfo()
}
